{"ast":null,"code":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _ReactElement = require('react/lib/ReactElement');\n\nvar _ReactElement2 = _interopRequireDefault(_ReactElement);\n\nvar _ReactCurrentOwner = require('react/lib/ReactCurrentOwner');\n\nvar _ReactCurrentOwner2 = _interopRequireDefault(_ReactCurrentOwner);\n\nvar _invariant = require('fbjs/lib/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _emptyObject = require('fbjs/lib/emptyObject');\n\nvar _emptyObject2 = _interopRequireDefault(_emptyObject);\n\nvar _warning = require('fbjs/lib/warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _ReactCompositeComponent = require('react-dom/lib/ReactCompositeComponent');\n\nvar _ReactCompositeComponent2 = _interopRequireDefault(_ReactCompositeComponent);\n\nvar _ReactInstanceMap = require('react-dom/lib/ReactInstanceMap');\n\nvar _ReactInstanceMap2 = _interopRequireDefault(_ReactInstanceMap);\n\nvar _ReactInstrumentation = require('react-dom/lib/ReactInstrumentation');\n\nvar _ReactInstrumentation2 = _interopRequireDefault(_ReactInstrumentation);\n\nvar _removeDevTool = require('./utils/removeDevTool');\n\nvar _removeDevTool2 = _interopRequireDefault(_removeDevTool);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar ReactCompositeComponentMixinImpl = function ReactCompositeComponentMixinImpl() {\n  _classCallCheck(this, ReactCompositeComponentMixinImpl);\n};\n\nReactCompositeComponentMixinImpl.prototype = _extends({}, ReactCompositeComponentMixinImpl.prototype, _ReactCompositeComponent2.default);\n\nfunction warnIfInvalidElement(Component, element) {\n  if (process.env.NODE_ENV !== 'production') {\n    (0, _warning2.default)(element === null || element === false || _ReactElement2.default.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component');\n  }\n}\n\nvar CompositeTypes = {\n  ImpureClass: 0,\n  PureClass: 1,\n  StatelessFunctional: 2\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\nfunction isPureComponent(Component) {\n  return !!(Component.prototype && Component.prototype.isPureReactComponent);\n} // Separated into a function to contain deoptimizations caused by try/finally.\n\n\nfunction measureLifeCyclePerf(fn, debugID, timerType) {\n  if (debugID === 0) {\n    // Top-level wrappers (see ReactMount) and empty components (see\n    // ReactDOMEmptyComponent) are invisible to hooks and devtools.\n    // Both are implementation details that should go away in the future.\n    return fn();\n  }\n\n  _ReactInstrumentation2.default.debugTool.onBeginLifeCycleTimer(debugID, timerType);\n\n  try {\n    return fn();\n  } finally {\n    _ReactInstrumentation2.default.debugTool.onEndLifeCycleTimer(debugID, timerType);\n  }\n}\n\nvar invokeComponentDidMountWithTimer = void 0;\n\nif (process.env.NODE_ENV !== 'production') {\n  invokeComponentDidMountWithTimer = function _invokeComponentDidMountWithTimer() {\n    var publicInstance = this._instance;\n\n    if (this._debugID !== 0) {\n      _ReactInstrumentation2.default.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidMount');\n    }\n\n    publicInstance.componentDidMount();\n\n    if (this._debugID !== 0) {\n      _ReactInstrumentation2.default.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidMount');\n    }\n  };\n}\n\nvar StatelessComponent = function () {\n  function StatelessComponent() {\n    _classCallCheck(this, StatelessComponent);\n  }\n\n  _createClass(StatelessComponent, [{\n    key: 'render',\n    value: function render() {\n      var componentCreator = _ReactInstanceMap2.default.get(this)._currentElement.type;\n\n      var element = componentCreator(this.props, this.context, this.updater);\n      warnIfInvalidElement(componentCreator, element);\n      return element;\n    }\n  }]);\n\n  return StatelessComponent;\n}();\n\nvar React3CompositeComponentWrapper = function (_ReactCompositeCompon) {\n  _inherits(React3CompositeComponentWrapper, _ReactCompositeCompon);\n\n  function React3CompositeComponentWrapper(element, react3RendererInstance) {\n    _classCallCheck(this, React3CompositeComponentWrapper);\n\n    var _this = _possibleConstructorReturn(this, (React3CompositeComponentWrapper.__proto__ || Object.getPrototypeOf(React3CompositeComponentWrapper)).call(this));\n\n    _this._react3RendererInstance = react3RendererInstance;\n\n    _this.construct(element);\n\n    return _this;\n  }\n\n  _createClass(React3CompositeComponentWrapper, [{\n    key: 'getHostMarkup',\n    value: function getHostMarkup() {\n      return _get(React3CompositeComponentWrapper.prototype.__proto__ || Object.getPrototypeOf(React3CompositeComponentWrapper.prototype), 'getHostNode', this).call(this);\n    }\n  }, {\n    key: 'construct',\n    value: function construct(element) {\n      _get(React3CompositeComponentWrapper.prototype.__proto__ || Object.getPrototypeOf(React3CompositeComponentWrapper.prototype), 'construct', this).call(this, element);\n\n      this._threeObject = null;\n    }\n    /**\r\n     * @see ReactCompositeComponent.\r\n     *\r\n     * Cloned because it needs to set _threeObject and remove dev tool\r\n     *\r\n     * Call the component's `render` method and update the DOM accordingly.\r\n     *\r\n     * @param {ReactReconcileTransaction} transaction\r\n     * @param context\r\n     * @internal\r\n     */\n\n  }, {\n    key: '_updateRenderedComponent',\n    value: function _updateRenderedComponent(transaction, context) {\n      var devToolRemoved = void 0;\n\n      if (process.env.NODE_ENV !== 'production') {\n        devToolRemoved = (0, _removeDevTool2.default)();\n      }\n\n      _get(React3CompositeComponentWrapper.prototype.__proto__ || Object.getPrototypeOf(React3CompositeComponentWrapper.prototype), '_updateRenderedComponent', this).call(this, transaction, context);\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (devToolRemoved) {\n          _removeDevTool2.default.restore();\n        }\n      }\n\n      this._threeObject = this._renderedComponent._threeObject;\n    }\n  }, {\n    key: '_instantiateReactComponent',\n    value: function _instantiateReactComponent(element, shouldHaveDebugID) {\n      return this._react3RendererInstance.instantiateReactComponent(element, shouldHaveDebugID);\n    } // TODO: prevInstance\n\n  }, {\n    key: '_replaceNodeWithMarkup',\n    value: function _replaceNodeWithMarkup(oldMarkup, nextMarkup) {\n      var parentMarkup = oldMarkup.parentMarkup;\n      var ownerChildrenMarkups = parentMarkup.childrenMarkup;\n      var indexInParent = ownerChildrenMarkups.indexOf(oldMarkup);\n\n      if (process.env.NODE_ENV !== 'production') {\n        (0, _invariant2.default)(indexInParent !== -1, 'The node has no parent');\n      } else {\n        (0, _invariant2.default)(indexInParent !== -1);\n      }\n\n      var parentInternalComponent = parentMarkup.threeObject.userData.react3internalComponent;\n      var originalInternalComponent = oldMarkup.threeObject.userData.react3internalComponent;\n      parentInternalComponent.removeChild(originalInternalComponent, oldMarkup);\n      var nextChild = nextMarkup.threeObject.userData.react3internalComponent;\n      nextChild._mountIndex = indexInParent;\n      parentInternalComponent.createChild(nextChild, null, nextMarkup);\n    } // See ReactCompositeComponent.mountComponent\n\n    /**\r\n     * Initializes the component, renders markup, and registers event listeners.\r\n     *\r\n     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\r\n     * @param {?object} hostParent\r\n     * @param {?object} hostContainerInfo\r\n     * @param {?object} context\r\n     * @return {?string} Rendered markup to be inserted into the DOM.\r\n     * @final\r\n     * @internal\r\n     */\n\n  }, {\n    key: 'mountComponent',\n    value: function mountComponent(transaction, hostParent, hostContainerInfo, context) {\n      this._context = context;\n      this._mountOrder = this._react3RendererInstance.nextMountID++;\n      this._hostParent = hostParent;\n      this._hostContainerInfo = hostContainerInfo;\n      var publicProps = this._currentElement.props;\n\n      var publicContext = this._processContext(context);\n\n      var Component = this._currentElement.type;\n      var updateQueue = transaction.getUpdateQueue(); // Initialize the public class\n\n      var doConstruct = shouldConstruct(Component);\n\n      var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);\n\n      var renderedElement = void 0; // Support functional components\n\n      if (!doConstruct && (!inst || !inst.render)) {\n        renderedElement = inst;\n        warnIfInvalidElement(Component, renderedElement);\n        (0, _invariant2.default)(inst === null || inst === false || _ReactElement2.default.isValidElement(inst), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component');\n        inst = new StatelessComponent(Component);\n        this._compositeType = CompositeTypes.StatelessFunctional;\n      } else if (isPureComponent(Component)) {\n        this._compositeType = CompositeTypes.PureClass;\n      } else {\n        this._compositeType = CompositeTypes.ImpureClass;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        // This will throw later in _renderValidatedComponent, but add an early\n        // warning now to help debugging\n        if (!inst.render) {\n          (0, _warning2.default)(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component');\n        }\n\n        var propsMutated = inst.props !== publicProps;\n        var componentName = Component.displayName || Component.name || 'Component';\n        (0, _warning2.default)(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\\'s constructor was passed.', componentName, componentName);\n      } // These should be set up in the constructor, but as a convenience for\n      // simpler class abstractions, we set them up after the fact.\n\n\n      inst.props = publicProps;\n      inst.context = publicContext;\n      inst.refs = _emptyObject2.default;\n      inst.updater = updateQueue;\n      this._instance = inst; // Store a reference from the instance back to the internal representation\n\n      _ReactInstanceMap2.default.set(inst, this);\n\n      if (process.env.NODE_ENV !== 'production') {\n        // Since plain JS classes are defined without any special initialization\n        // logic, we can not catch common errors early. Therefore, we have to\n        // catch them here, at initialization time, instead.\n        (0, _warning2.default)(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component');\n        (0, _warning2.default)(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component');\n        (0, _warning2.default)(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component');\n        (0, _warning2.default)(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component');\n        (0, _warning2.default)(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component');\n        (0, _warning2.default)(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component');\n        (0, _warning2.default)(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component');\n      }\n\n      var initialState = inst.state;\n\n      if (initialState === undefined) {\n        initialState = null;\n        inst.state = initialState;\n      }\n\n      if (!((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState))) {\n        if (process.env.NODE_ENV !== 'production') {\n          (0, _invariant2.default)(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent');\n        } else {\n          (0, _invariant2.default)(false);\n        }\n      }\n\n      this._pendingStateQueue = null;\n      this._pendingReplaceState = false;\n      this._pendingForceUpdate = false;\n      var markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);\n\n      if (inst.componentDidMount) {\n        if (process.env.NODE_ENV !== 'production') {\n          transaction.getReactMountReady().enqueue(invokeComponentDidMountWithTimer, this);\n        } else {\n          transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);\n        }\n      }\n\n      return markup;\n    }\n  }, {\n    key: '_constructComponent',\n    value: function _constructComponent(doConstruct, publicProps, publicContext, updateQueue) {\n      if (process.env.NODE_ENV !== 'production') {\n        _ReactCurrentOwner2.default.current = this;\n\n        try {\n          return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);\n        } finally {\n          _ReactCurrentOwner2.default.current = null;\n        }\n      } else {\n        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);\n      }\n    }\n  }, {\n    key: '_constructComponentWithoutOwner',\n    value: function _constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue) {\n      var Component = this._currentElement.type;\n\n      if (doConstruct) {\n        if (process.env.NODE_ENV !== 'production') {\n          return measureLifeCyclePerf(function () {\n            return new Component(publicProps, publicContext, updateQueue);\n          }, this._debugID, 'ctor');\n        }\n\n        return new Component(publicProps, publicContext, updateQueue);\n      } // This can still be an instance in case of factory components\n      // but we'll count this as time spent rendering as the more common case.\n\n\n      if (process.env.NODE_ENV !== 'production') {\n        return measureLifeCyclePerf(function () {\n          return Component(publicProps, publicContext, updateQueue);\n        }, this._debugID, 'render');\n      }\n\n      return Component(publicProps, publicContext, updateQueue);\n    }\n    /**\r\n     * Needs to be overwritten because emptyObject points to another...\r\n     *\r\n     * Lazily allocates the refs object and stores `component` as `ref`.\r\n     *\r\n     * @param {string} ref Reference name.\r\n     * @param {*} component Component to store as `ref`.\r\n     * @final\r\n     * @private\r\n     */\n\n  }, {\n    key: 'attachRef',\n    value: function attachRef(ref, component) {\n      var inst = this.getPublicInstance();\n      var refs = inst.refs === _emptyObject2.default ? inst.refs = {} : inst.refs;\n      refs[ref] = component.getPublicInstance();\n    }\n  }]);\n\n  return React3CompositeComponentWrapper;\n}(ReactCompositeComponentMixinImpl);\n\nmodule.exports = React3CompositeComponentWrapper;","map":null,"metadata":{},"sourceType":"script"}