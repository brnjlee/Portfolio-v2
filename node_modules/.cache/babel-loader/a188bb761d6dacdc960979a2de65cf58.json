{"ast":null,"code":"'use strict';\n\nvar _invariant = require('fbjs/lib/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _React3ComponentFlags = require('./React3ComponentFlags');\n\nvar _React3ComponentFlags2 = _interopRequireDefault(_React3ComponentFlags);\n\nvar _idPropertyName = require('./utils/idPropertyName');\n\nvar _idPropertyName2 = _interopRequireDefault(_idPropertyName);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar internalInstanceKey = '__react3InternalInstance$' + Math.random().toString(36).slice(2);\n/**\r\n * Drill down (through composites and empty components) until we get a host or\r\n * host text component.\r\n *\r\n * This is pretty polymorphic but unavoidable with the current structure we have\r\n * for `_renderedChildren`.\r\n */\n// see ReactDOMComponentTree\n\nfunction getRenderedHostOrTextFromComponent(component) {\n  var result = component;\n  var rendered = result._renderedComponent;\n\n  while (rendered) {\n    result = rendered;\n    rendered = result._renderedComponent;\n  }\n\n  return result;\n}\n/**\r\n * Populate `_hostMarkup` on the rendered host/text component with the given\r\n * markup. The passed `instance` can be a composite.\r\n */\n\n\nfunction precacheMarkup(instance, markup) {\n  (0, _invariant2.default)(!!markup, 'Markup is null!');\n  var hostInstance = getRenderedHostOrTextFromComponent(instance);\n  hostInstance._hostMarkup = markup;\n  markup[internalInstanceKey] = hostInstance;\n}\n\nfunction uncacheMarkup(inst) {\n  var markup = inst._hostMarkup;\n\n  if (markup) {\n    delete markup[internalInstanceKey];\n    inst._hostMarkup = null;\n  }\n}\n/**\r\n * Populate `_hostMarkup` on each child of `inst`, assuming that the children\r\n * match up with the children of `markup`.\r\n *\r\n * We cache entire levels at once to avoid an n^2 problem where we access the\r\n * children of a markup sequentially and have to walk from the start to our target\r\n * markup every time.\r\n *\r\n * Since we update `_renderedChildren` and the actual DOM at (slightly)\r\n * different times, we could race here and see a newer `_renderedChildren` than\r\n * the markups we see. To avoid this, ReactMultiChild calls\r\n * `prepareToManageChildren` before we change `_renderedChildren`, at which\r\n * time the container's child markups are always cached (until it unmounts).\r\n */\n\n\nfunction precacheChildMarkups(instance, markup) {\n  if ((instance._flags & _React3ComponentFlags2.default.hasCachedChildMarkups) !== 0) {\n    return;\n  }\n\n  var renderedChildren = instance._renderedChildren;\n  var childrenNames = Object.keys(renderedChildren);\n  var childrenMarkup = markup.childrenMarkup;\n  /* eslint-disable no-labels, no-unused-labels, no-restricted-syntax */\n\n  outer: for (var i = 0; i < childrenNames.length; ++i) {\n    /* eslint-enable no-labels, no-unused-labels, no-restricted-syntax */\n    var childName = childrenNames[i];\n    var childInst = renderedChildren[childName]; // TODO implement _domID\n\n    var childID = getRenderedHostOrTextFromComponent(childInst)._hostID;\n\n    if (childID === 0) {\n      // We're currently unmounting this child in ReactMultiChild; skip it.\n      continue;\n    }\n\n    for (var j = 0; j < childrenMarkup.length; ++j) {\n      var childMarkup = childrenMarkup[j];\n\n      if (childMarkup[_idPropertyName2.default] === childID) {\n        precacheMarkup(childInst, childMarkup);\n        continue outer; // eslint-disable-line no-labels\n      }\n    } // We reached the end of the DOM children without finding an ID match.\n\n\n    if (process.env.NODE_ENV !== 'production') {\n      (0, _invariant2.default)(false, 'Unable to find element with ID %s.', childID);\n    } else {\n      (0, _invariant2.default)(false);\n    }\n    /* original implementation:\r\n    // We assume the child nodes are in the same order as the child instances.\r\n    for (; childMarkup !== null; childMarkup = childMarkup.nextSibling) {\r\n      if (childMarkup.nodeType === 1 && // Element.ELEMENT_NODE\r\n        childMarkup.getAttribute(ATTR_NAME) === String(childID) ||\r\n        childMarkup.nodeType === 8 &&\r\n        childMarkup.nodeValue === ` react-text: ${childID} ` ||\r\n        childMarkup.nodeType === 8 &&\r\n        childMarkup.nodeValue === ` react-empty: ${childID} `) {\r\n        precacheNode(childInst, childMarkup);\r\n        continue outer; // eslint-disable-line no-labels\r\n      }\r\n    }\r\n    */\n\n  }\n\n  instance._flags |= _React3ComponentFlags2.default.hasCachedChildMarkups;\n} // see ReactDOMComponentTree:getClosestInstanceFromNode\n\n\nfunction getClosestInstanceFromMarkup(markup) {\n  if (markup[internalInstanceKey]) {\n    return markup[internalInstanceKey];\n  }\n\n  var currentMarkup = markup; // Walk up the tree until we find an ancestor whose instance we have cached.\n\n  var parentMarkupsWithoutInstanceKey = [];\n\n  while (!currentMarkup[internalInstanceKey]) {\n    parentMarkupsWithoutInstanceKey.push(currentMarkup);\n\n    if (currentMarkup.parentMarkup) {\n      currentMarkup = currentMarkup.parentMarkup;\n    } else {\n      // Top of the tree. This markup must not be part of a React tree (or is\n      // unmounted, potentially).\n      return null;\n    }\n  } // if we're here, then currentMarkup does have internalInstanceKey, otherwise\n  // we would have reached the top of the tree and returned null.\n\n\n  var closest = void 0;\n  var instance = currentMarkup[internalInstanceKey]; // traversing from greatest ancestor (e.g. parent of all parents) downwards\n  // e.g. walk down the tree now\n\n  while (instance) {\n    closest = instance;\n\n    if (!parentMarkupsWithoutInstanceKey.length) {\n      break;\n    } // this will ensure that all children of the current greatest ancestor\n    // have internalInstanceKey\n\n\n    precacheChildMarkups(instance, currentMarkup);\n    currentMarkup = parentMarkupsWithoutInstanceKey.pop();\n    instance = currentMarkup[internalInstanceKey];\n  }\n  /* original impl of ^\r\n  for (; currentMarkup && (instance = currentMarkup[internalInstanceKey]);\r\n         currentMarkup = parentMarkupsWithoutInstanceKey.pop()) {\r\n    closest = instance;\r\n    if (parentMarkupsWithoutInstanceKey.length) {\r\n      this.precacheChildMarkups(instance, currentMarkup);\r\n    }\r\n  }\r\n  */\n\n\n  return closest;\n} // see ReactDOMComponentTree:getInstanceFromNode\n\n\nfunction getInstanceFromMarkup(markup) {\n  var inst = getClosestInstanceFromMarkup(markup);\n\n  if (inst !== null && inst._hostMarkup === markup) {\n    return inst;\n  }\n\n  return null;\n}\n/**\r\n * Given an InternalComponent, return the corresponding\r\n * host markup.\r\n */\n\n\nfunction getMarkupFromInstance(inst) {\n  // Without this first invariant, passing a non-React3-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  if (process.env.NODE_ENV !== 'production') {\n    (0, _invariant2.default)(inst._hostMarkup !== undefined, 'getMarkupFromInstance: Invalid argument.');\n  } else {\n    (0, _invariant2.default)(inst._hostMarkup !== undefined);\n  }\n\n  if (inst._hostMarkup) {\n    return inst._hostMarkup;\n  }\n\n  var currentInstance = inst; // Walk up the tree until we find an ancestor whose host node we have cached.\n\n  var parents = [];\n\n  while (!currentInstance._hostMarkup) {\n    parents.push(currentInstance);\n    (0, _invariant2.default)(currentInstance._hostParent, 'React3 tree root should always have a node reference.');\n    currentInstance = currentInstance._hostParent;\n  } // Now parents contains each ancestor that does *not* have a cached host\n  // markup, and `currentInstance` is the deepest ancestor that does.\n\n\n  for (; parents.length; currentInstance = parents.pop()) {\n    precacheChildMarkups(currentInstance, currentInstance._hostMarkup);\n  }\n\n  return currentInstance._hostMarkup;\n}\n\nmodule.exports = {\n  getMarkupFromInstance: getMarkupFromInstance,\n  getInstanceFromMarkup: getInstanceFromMarkup,\n  precacheMarkup: precacheMarkup,\n  uncacheMarkup: uncacheMarkup,\n  precacheChildMarkups: precacheChildMarkups,\n  getClosestInstanceFromMarkup: getClosestInstanceFromMarkup,\n  getRenderedHostOrTextFromComponent: getRenderedHostOrTextFromComponent\n};","map":null,"metadata":{},"sourceType":"script"}