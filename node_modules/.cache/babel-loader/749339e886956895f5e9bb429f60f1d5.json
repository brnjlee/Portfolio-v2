{"ast":null,"code":"'use strict';\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _class, _temp, _initialiseProps;\n\nvar _three = require('three');\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _invariant = require('fbjs/lib/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _warning = require('fbjs/lib/warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _ReactUpdates = require('react-dom/lib/ReactUpdates');\n\nvar _ReactUpdates2 = _interopRequireDefault(_ReactUpdates);\n\nvar _raf = require('raf');\n\nvar _raf2 = _interopRequireDefault(_raf);\n\nvar _Viewport = require('./Viewport');\n\nvar _Viewport2 = _interopRequireDefault(_Viewport);\n\nvar _Module = require('./Module');\n\nvar _Module2 = _interopRequireDefault(_Module);\n\nvar _React3Renderer = require('./React3Renderer');\n\nvar _React3Renderer2 = _interopRequireDefault(_React3Renderer);\n\nvar _ResourceContainer = require('./Resources/ResourceContainer');\n\nvar _ResourceContainer2 = _interopRequireDefault(_ResourceContainer);\n\nvar _CameraUtils = require('./utils/CameraUtils');\n\nvar _CameraUtils2 = _interopRequireDefault(_CameraUtils);\n\nvar _isWebglSupported = require('./utils/isWebglSupported');\n\nvar _isWebglSupported2 = _interopRequireDefault(_isWebglSupported);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar rendererProperties = ['gammaInput', 'gammaOutput'];\nvar React3DInstance = (_temp = _class = function () {\n  function React3DInstance(props, rendererInstance) {\n    var _this = this;\n\n    _classCallCheck(this, React3DInstance);\n\n    _initialiseProps.call(this);\n\n    var mainCamera = props.mainCamera,\n        onAnimate = props.onAnimate,\n        onRecreateCanvas = props.onRecreateCanvas,\n        onRendererUpdated = props.onRendererUpdated,\n        onManualRenderTriggerCreated = props.onManualRenderTriggerCreated,\n        forceManualRender = props.forceManualRender;\n    this._parameters = _extends({}, props);\n    this._rendererInstance = rendererInstance;\n    this._mounted = false;\n    this._willUnmount = false;\n    this._scene = null;\n    this._mainCameraName = mainCamera;\n    this._viewports = [];\n    /**\r\n     * @type {Array.<React3Module>}\r\n     */\n\n    this._modules = [];\n    this._resourceContainers = [];\n    this._recreateCanvasCallback = onRecreateCanvas;\n    this._rendererUpdatedCallback = onRendererUpdated;\n    this._manualRenderTriggerCallback = onManualRenderTriggerCreated;\n    this._forceManualRender = forceManualRender;\n    this._warnedAboutManualRendering = false;\n    this._canvas = null;\n    this._onAnimate = onAnimate;\n    this._objectsByUUID = {};\n    this._materials = [];\n    this._geometries = [];\n    this._textures = [];\n    this._objectsByName = {};\n    this._lastRenderMode = null;\n\n    this._renderTrigger = function (renderThisFrame) {\n      if (renderThisFrame) {\n        _this._render();\n      } else if (_this._renderRequest === null) {\n        _this._renderRequest = (0, _raf2.default)(_this._render);\n      }\n    };\n\n    this.uuid = THREE.Math.generateUUID();\n    this.userData = {};\n\n    if (process.env.NODE_ENV !== 'production' || process.env.ENABLE_REACT_ADDON_HOOKS === 'true') {\n      this._highlightScene = new THREE.Scene();\n      this._highlightGeometry = new THREE.BoxGeometry(1, 1, 1);\n      this._highlightMaterial = new THREE.MeshBasicMaterial({\n        color: 0x0000ff,\n        transparent: true,\n        opacity: 0.4\n      });\n      this._highlightObjectId = null;\n      this._getHighlightBoundingBox = null;\n\n      this._hideHighlight = function () {\n        _this._highlightObjectId = null;\n        _this._getHighlightBoundingBox = null;\n      };\n\n      this._objectHighlighted = function (info) {\n        var uuid = info.uuid,\n            boundingBoxFunc = info.boundingBoxFunc;\n        var obj = void 0;\n\n        if (_this._highlightObjectId) {\n          obj = _this._objectsByUUID[_this._highlightObjectId];\n          obj.userData.events.removeListener('hideHighlight', _this._hideHighlight);\n        }\n\n        _this._highlightObjectId = uuid;\n        _this._getHighlightBoundingBox = boundingBoxFunc;\n        obj = _this._objectsByUUID[uuid];\n        obj.userData.events.once('hideHighlight', _this._hideHighlight);\n      };\n    }\n  }\n\n  _createClass(React3DInstance, [{\n    key: '_createRenderer',\n    value: function _createRenderer() {\n      if (!this._canvas) {\n        return;\n      }\n\n      var parameters = this._parameters;\n      var rendererArgs = {\n        canvas: this._canvas,\n        precision: parameters.precision,\n        alpha: parameters.alpha,\n        premultipliedAlpha: parameters.premultipliedAlpha,\n        antialias: parameters.antialias,\n        stencil: parameters.stencil,\n        preserveDrawingBuffer: parameters.preserveDrawingBuffer,\n        depth: parameters.depth,\n        logarithmicDepthBuffer: parameters.logarithmicDepthBuffer\n      };\n\n      if (this._parameters.customRenderer) {\n        this._renderer = this._parameters.customRenderer(rendererArgs);\n      } else {\n        this._renderer = (0, _isWebglSupported2.default)() ? new THREE.WebGLRenderer(rendererArgs) : new THREE.CanvasRenderer(rendererArgs);\n      }\n\n      if (this._rendererUpdatedCallback) {\n        this._rendererUpdatedCallback(this._renderer);\n      }\n\n      var renderer = this._renderer;\n\n      if (parameters.hasOwnProperty('pixelRatio')) {\n        renderer.setPixelRatio(parameters.pixelRatio);\n      }\n\n      if (parameters.hasOwnProperty('sortObjects')) {\n        renderer.sortObjects = parameters.sortObjects;\n      }\n\n      var hasClearColor = parameters.hasOwnProperty('clearColor');\n      var hasClearAlpha = parameters.hasOwnProperty('clearAlpha');\n\n      if (hasClearColor || hasClearAlpha) {\n        var clearColor = void 0;\n\n        if (hasClearColor) {\n          clearColor = parameters.clearColor;\n        } else {\n          clearColor = new THREE.Color(0x000000); // default clear color\n        }\n\n        if (hasClearAlpha) {\n          if (process.env.NODE_ENV !== 'production') {\n            (0, _warning2.default)(parameters.alpha === true, 'The `clearAlpha` property' + ' requires the `alpha` property to be `true`.');\n          }\n\n          renderer.setClearColor(clearColor, parameters.clearAlpha);\n        } else {\n          renderer.setClearColor(clearColor);\n        }\n      }\n\n      if (parameters.hasOwnProperty('shadowMapEnabled')) {\n        renderer.shadowMap.enabled = parameters.shadowMapEnabled;\n      }\n\n      if (parameters.hasOwnProperty('shadowMapType')) {\n        renderer.shadowMap.type = parameters.shadowMapType;\n      }\n\n      if (parameters.hasOwnProperty('shadowMapCullFace')) {\n        renderer.shadowMap.cullFace = parameters.shadowMapCullFace;\n      }\n\n      if (parameters.hasOwnProperty('shadowMapDebug')) {\n        renderer.shadowMap.debug = parameters.shadowMapDebug;\n      }\n\n      rendererProperties.forEach(function (propertyName) {\n        if (parameters.hasOwnProperty(propertyName)) {\n          renderer[propertyName] = parameters[propertyName];\n        }\n      });\n      renderer.setSize(parameters.width, parameters.height);\n    }\n  }, {\n    key: 'initialize',\n    value: function initialize() {\n      this.userData.events.on('animate', this._callOnAnimate);\n\n      if (this._forceManualRender) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (!this._manualRenderTriggerCallback && !this._warnedAboutManualRendering) {\n            this._warnedAboutManualRendering = true;\n            (0, _warning2.default)(false, 'The `forceManualRender` property requires the ' + '`onManualRenderTriggerCreated` property to be set.');\n          }\n        }\n\n        this._renderRequest = null;\n      } else {\n        this._renderRequest = (0, _raf2.default)(this._render);\n      }\n\n      if (this._manualRenderTriggerCallback) {\n        this._manualRenderTriggerCallback(this._renderTrigger);\n      }\n    }\n  }, {\n    key: 'getObjectsByName',\n    value: function getObjectsByName(objectName) {\n      var objectsByName = this._objectsByName[objectName];\n      var result = void 0;\n\n      if (objectsByName) {\n        var idToObjectMap = objectsByName.values;\n        result = Object.keys(idToObjectMap).map(function (name) {\n          return idToObjectMap[name];\n        });\n      } else {\n        result = [];\n      }\n\n      return result;\n    }\n  }, {\n    key: 'addAnimateListener',\n    value: function addAnimateListener(callback) {\n      this.userData.events.on('animate', callback);\n    }\n  }, {\n    key: 'removeAnimateListener',\n    value: function removeAnimateListener(callback) {\n      this.userData.events.removeListener('animate', callback);\n    }\n  }, {\n    key: 'addBeforeRenderListener',\n    value: function addBeforeRenderListener(callback) {\n      this.userData.events.on('preRender', callback);\n    }\n  }, {\n    key: 'removeBeforeRenderListener',\n    value: function removeBeforeRenderListener(callback) {\n      this.userData.events.removeListener('preRender', callback);\n    }\n  }, {\n    key: 'addChildren',\n    value: function addChildren(children) {\n      for (var i = 0; i < children.length; ++i) {\n        var child = children[i];\n\n        if (child instanceof THREE.Scene) {\n          this.setScene(child);\n        } else if (child instanceof _Viewport2.default) {\n          this.addViewport(child);\n        } else if (child instanceof _Module2.default) {\n          this.addModule(child);\n        } else if (child instanceof _ResourceContainer2.default) {\n          this.addResourceContainer(child);\n        } else {\n          (0, _invariant2.default)(false, 'The react3 component should only contain ' + '<viewport/>s or <scene/>s or <resources/>.');\n        }\n      }\n    }\n  }, {\n    key: 'removeChild',\n    value: function removeChild(child) {\n      if (child instanceof THREE.Scene) {\n        if (this._scene === child) {\n          this.setScene(null);\n        }\n      } else if (child instanceof _Viewport2.default) {\n        this.removeViewport(child);\n      } else if (child instanceof _Module2.default) {\n        this.removeModule(child);\n      } else if (child instanceof _ResourceContainer2.default) {\n        this.removeResourceContainer(child);\n      } else {\n        (0, _invariant2.default)(false, 'The react3 component should only contain ' + '<viewport/>s or <scene/>s, <module/>s or <resources/>.');\n      }\n    }\n  }, {\n    key: '_renderScene',\n    value: function _renderScene(camera) {\n      this._renderer.render(this._scene, camera);\n\n      if (process.env.NODE_ENV !== 'production' || process.env.ENABLE_REACT_ADDON_HOOKS === 'true') {\n        if (this._highlightObjectId !== null) {\n          var boundingBoxes = this._getHighlightBoundingBox();\n\n          var highlightScene = this._highlightScene;\n          var diff = highlightScene.children.length - boundingBoxes.length;\n\n          if (diff > 0) {\n            for (var i = 0; i < diff; i++) {\n              highlightScene.remove(highlightScene.children[0]);\n            }\n          } else if (diff < 0) {\n            for (var _i = 0; _i < -diff; _i++) {\n              highlightScene.add(new THREE.Mesh(this._highlightGeometry, this._highlightMaterial));\n            }\n          }\n\n          for (var _i2 = 0; _i2 < boundingBoxes.length; ++_i2) {\n            var boundingBox = boundingBoxes[_i2];\n            var center = boundingBox.min.clone().add(boundingBox.max).multiplyScalar(0.5);\n            var size = boundingBox.max.clone().sub(boundingBox.min);\n            var highlightCube = highlightScene.children[_i2];\n            highlightCube.position.copy(center);\n            highlightCube.scale.copy(size);\n          }\n\n          var autoClear = this._renderer.autoClear;\n          this._renderer.autoClear = false;\n\n          this._renderer.render(highlightScene, camera);\n\n          this._renderer.autoClear = autoClear;\n        }\n      }\n    }\n  }, {\n    key: 'setScene',\n    value: function setScene(scene) {\n      if (process.env.NODE_ENV !== 'production') {\n        (0, _invariant2.default)(!(this._scene && scene), 'There can only be one scene in <react3/>');\n      }\n\n      this._scene = scene;\n    }\n  }, {\n    key: 'addViewport',\n    value: function addViewport(viewport) {\n      this._viewports.push(viewport);\n    }\n  }, {\n    key: 'removeViewport',\n    value: function removeViewport(viewport) {\n      var index = this._viewports.indexOf(viewport);\n\n      if (process.env.NODE_ENV !== 'production') {\n        (0, _invariant2.default)(index !== -1, 'A viewport has been removed from ' + '<react3/> but it was not present in it...');\n      }\n\n      this._viewports.splice(index, 1);\n    }\n  }, {\n    key: 'addResourceContainer',\n    value: function addResourceContainer(resourceContainer) {\n      this._resourceContainers.push(resourceContainer);\n    }\n  }, {\n    key: 'removeResourceContainer',\n    value: function removeResourceContainer(resourceContainer) {\n      var index = this._resourceContainers.indexOf(resourceContainer);\n\n      if (process.env.NODE_ENV !== 'production') {\n        (0, _invariant2.default)(index !== -1, 'A resource container has been removed ' + 'from <react3/> but it was not present in it...');\n      }\n\n      this._resourceContainers.splice(index, 1);\n    }\n  }, {\n    key: 'addModule',\n    value: function addModule(module) {\n      this._modules.push(module);\n    }\n  }, {\n    key: 'removeModule',\n    value: function removeModule(module) {\n      var index = this._modules.indexOf(module);\n\n      if (process.env.NODE_ENV !== 'production') {\n        (0, _invariant2.default)(index !== -1, 'A module has been removed from ' + '<react3/> but it was not present in it...');\n      }\n\n      this._modules.splice(index, 1);\n    }\n  }, {\n    key: 'updateWidth',\n    value: function updateWidth(newWidth) {\n      this._parameters.width = newWidth;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this._renderer.setSize(this._parameters.width, this._parameters.height);\n    }\n  }, {\n    key: 'updateOnRecreateCanvas',\n    value: function updateOnRecreateCanvas(threeObject, callback) {\n      this._recreateCanvasCallback = callback;\n    }\n  }, {\n    key: 'updateOnRendererUpdated',\n    value: function updateOnRendererUpdated(callback) {\n      this._rendererUpdatedCallback = callback;\n    }\n  }, {\n    key: 'updateOnManualRenderTriggerCreated',\n    value: function updateOnManualRenderTriggerCreated(callback) {\n      this._manualRenderTriggerCallback = callback;\n\n      if (callback) {\n        this._manualRenderTriggerCallback(this._renderTrigger);\n      }\n    }\n  }, {\n    key: 'updateForceManualRender',\n    value: function updateForceManualRender(forceManualRender) {\n      if (this._forceManualRender === forceManualRender) {\n        return;\n      }\n\n      this._forceManualRender = forceManualRender;\n\n      if (forceManualRender) {\n        // was just set to be forced\n        _raf2.default.cancel(this._renderRequest);\n\n        this._renderRequest = null;\n      } else {\n        // was just restored\n        this._renderRequest = (0, _raf2.default)(this._render);\n      }\n    }\n  }, {\n    key: 'updateHeight',\n    value: function updateHeight(newHeight) {\n      this._parameters.height = newHeight;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this._renderer.setSize(this._parameters.width, this._parameters.height);\n    }\n  }, {\n    key: 'updatePixelRatio',\n    value: function updatePixelRatio(newPixelRatio) {\n      this._parameters.pixelRatio = newPixelRatio;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this._renderer.setPixelRatio(newPixelRatio);\n\n      this._renderer.setSize(this._parameters.width, this._parameters.height);\n    }\n  }, {\n    key: 'updateSortObjects',\n    value: function updateSortObjects(sortObjects) {\n      this._parameters.sortObjects = sortObjects;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this._renderer.sortObjects = sortObjects;\n    }\n  }, {\n    key: 'updateAntialias',\n    value: function updateAntialias(antialias) {\n      this._parameters.antialias = antialias; // no renderer, this only happens initially or we're about to recreate it anyway.\n      // unless something broke, then we have bigger problems...\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this.refreshRenderer();\n    }\n  }, {\n    key: 'updatePrecision',\n    value: function updatePrecision(precision) {\n      this._parameters.precision = precision;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this.refreshRenderer();\n    }\n  }, {\n    key: 'updateAlpha',\n    value: function updateAlpha(alpha) {\n      this._parameters.alpha = alpha;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this.refreshRenderer();\n    }\n  }, {\n    key: 'updatePremultipliedAlpha',\n    value: function updatePremultipliedAlpha(premultipliedAlpha) {\n      this._parameters.premultipliedAlpha = premultipliedAlpha;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this.refreshRenderer();\n    }\n  }, {\n    key: 'updateStencil',\n    value: function updateStencil(stencil) {\n      this._parameters.stencil = stencil;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this.refreshRenderer();\n    }\n  }, {\n    key: 'updatePreserveDrawingBuffer',\n    value: function updatePreserveDrawingBuffer(preserveDrawingBuffer) {\n      this._parameters.preserveDrawingBuffer = preserveDrawingBuffer;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this.refreshRenderer();\n    }\n  }, {\n    key: 'updateDepth',\n    value: function updateDepth(depth) {\n      this._parameters.depth = depth;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this.refreshRenderer();\n    }\n  }, {\n    key: 'updateLogarithmicDepthBuffer',\n    value: function updateLogarithmicDepthBuffer(logarithmicDepthBuffer) {\n      this._parameters.logarithmicDepthBuffer = logarithmicDepthBuffer;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this.refreshRenderer();\n    }\n  }, {\n    key: 'updateShadowMapEnabled',\n    value: function updateShadowMapEnabled(shadowMapEnabled) {\n      this._parameters.shadowMapEnabled = shadowMapEnabled;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this._renderer.shadowMap.enabled = shadowMapEnabled;\n      this.allMaterialsNeedUpdate(true);\n    }\n  }, {\n    key: 'updateShadowMapType',\n    value: function updateShadowMapType(shadowMapType) {\n      this._parameters.shadowMapType = shadowMapType;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this._renderer.shadowMap.type = shadowMapType;\n      this.allMaterialsNeedUpdate(true);\n    }\n  }, {\n    key: 'updateShadowMapCullFace',\n    value: function updateShadowMapCullFace(shadowMapCullFace) {\n      this._parameters.shadowMapCullFace = shadowMapCullFace;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this._renderer.shadowMap.cullFace = shadowMapCullFace;\n      this.allMaterialsNeedUpdate(true);\n    }\n  }, {\n    key: 'updateShadowMapDebug',\n    value: function updateShadowMapDebug(shadowMapDebug) {\n      this._parameters.shadowMapDebug = shadowMapDebug;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this._renderer.shadowMap.debug = shadowMapDebug;\n      this.allMaterialsNeedUpdate(true);\n    }\n  }, {\n    key: 'updateCanvas',\n    value: function updateCanvas(canvas) {\n      this._canvas = canvas;\n\n      if (this._renderer) {\n        this.disposeResourcesAndRenderer();\n\n        var contextLossExtension = this._renderer.extensions.get('WEBGL_lose_context');\n\n        if (contextLossExtension) {\n          // noinspection JSUnresolvedFunction\n          contextLossExtension.loseContext();\n        }\n      }\n\n      this._createRenderer();\n    }\n  }, {\n    key: 'updateGammaInput',\n    value: function updateGammaInput(gammaInput) {\n      this._parameters.gammaInput = gammaInput;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this._renderer.gammaInput = gammaInput;\n      this.allMaterialsNeedUpdate(true);\n    }\n  }, {\n    key: 'updateGammaOutput',\n    value: function updateGammaOutput(gammaOutput) {\n      this._parameters.gammaOutput = gammaOutput;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this._renderer.gammaOutput = gammaOutput;\n      this.allMaterialsNeedUpdate(true);\n    }\n  }, {\n    key: 'updateContext',\n    value: function updateContext(context) {\n      this._parameters.context = context;\n    }\n  }, {\n    key: 'updateMainCamera',\n    value: function updateMainCamera(mainCamera) {\n      this._parameters.mainCamera = mainCamera;\n      this._mainCameraName = mainCamera;\n    }\n  }, {\n    key: 'updateCustomRenderer',\n    value: function updateCustomRenderer(customRenderer) {\n      this._parameters.customRenderer = customRenderer;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      this.refreshRenderer();\n    }\n  }, {\n    key: 'updateOnAnimate',\n    value: function updateOnAnimate(onAnimate) {\n      this._parameters.onAnimate = onAnimate;\n      this._onAnimate = onAnimate;\n    }\n  }, {\n    key: 'updateClearColor',\n    value: function updateClearColor(clearColor) {\n      this._parameters.clearColor = clearColor;\n\n      if (!this._renderer) {\n        return;\n      }\n\n      if (this._parameters.hasOwnProperty('clearAlpha')) {\n        this._renderer.setClearColor(clearColor, this._parameters.clearAlpha);\n      } else {\n        this._renderer.setClearColor(clearColor);\n      }\n    }\n  }, {\n    key: 'updateClearAlpha',\n    value: function updateClearAlpha(clearAlpha) {\n      var parameters = this._parameters;\n\n      if (clearAlpha === undefined) {\n        delete parameters.clearAlpha;\n      } else {\n        parameters.clearAlpha = clearAlpha;\n      }\n\n      if (!this._renderer) {\n        return;\n      }\n\n      var clearColor = void 0;\n\n      if (parameters.hasOwnProperty('clearColor')) {\n        clearColor = parameters.clearColor;\n      } else {\n        clearColor = new THREE.Color(0x000000); // default clear color\n      }\n\n      if (clearAlpha !== undefined) {\n        this._renderer.setClearColor(clearColor, clearAlpha);\n      } else {\n        this._renderer.setClearColor(clearColor);\n      }\n    }\n  }, {\n    key: 'refreshRenderer',\n    value: function refreshRenderer() {\n      this.disposeResourcesAndRenderer();\n\n      var contextLossExtension = this._renderer.extensions.get('WEBGL_lose_context');\n\n      delete this._renderer;\n\n      if (this._rendererUpdatedCallback) {\n        this._rendererUpdatedCallback(null);\n      }\n\n      this.userData.events.removeListener('animate', this._callOnAnimate);\n      this.userData.events.removeAllListeners();\n\n      if (this._renderRequest !== null) {\n        _raf2.default.cancel(this._renderRequest);\n\n        this._renderRequest = null;\n      }\n\n      if (contextLossExtension && this._canvas) {\n        // noinspection JSUnresolvedFunction\n        contextLossExtension.loseContext();\n\n        this._recreateCanvasCallback();\n      } else {\n        this._recreateCanvasCallback();\n      }\n    }\n  }, {\n    key: 'disposeResourcesAndRenderer',\n    value: function disposeResourcesAndRenderer() {\n      for (var i = 0; i < this._materials.length; ++i) {\n        var material = this._materials[i];\n        material.dispose();\n      }\n\n      for (var _i3 = 0; _i3 < this._geometries.length; ++_i3) {\n        var geometry = this._geometries[_i3];\n        geometry.dispose();\n      }\n\n      for (var _i4 = 0; _i4 < this._textures.length; ++_i4) {\n        var texture = this._textures[_i4];\n        texture.dispose();\n      }\n\n      this._renderer.dispose();\n    }\n  }, {\n    key: 'willUnmount',\n    value: function willUnmount() {\n      this._willUnmount = true;\n    }\n  }, {\n    key: 'unmount',\n    value: function unmount() {\n      this._mounted = false;\n\n      if (this._renderRequest !== null) {\n        _raf2.default.cancel(this._renderRequest);\n\n        this._renderRequest = null;\n      }\n\n      this.userData.events.removeListener('animate', this._callOnAnimate);\n      this.userData.events.removeAllListeners();\n      delete this._rendererInstance;\n\n      if (this._renderer) {\n        var contextLossExtension = this._renderer.extensions.get('WEBGL_lose_context');\n\n        if (contextLossExtension) {\n          // noinspection JSUnresolvedFunction\n          contextLossExtension.loseContext();\n        }\n\n        this.disposeResourcesAndRenderer();\n        delete this._renderer;\n\n        if (this._rendererUpdatedCallback) {\n          this._rendererUpdatedCallback(null);\n        }\n      }\n\n      delete this._parameters;\n      (0, _invariant2.default)(Object.keys(this._objectsByUUID).length === 0, 'Failed to cleanup some child objects for React3DInstance');\n      delete this._objectsByUUID;\n      delete this._viewports;\n      delete this._scene;\n\n      if (process.env.NODE_ENV !== 'production' || process.env.ENABLE_REACT_ADDON_HOOKS === 'true') {\n        delete this._highlightScene;\n        delete this._highlightObjectId;\n        delete this._getHighlightBoundingBox;\n      }\n    }\n  }, {\n    key: 'objectMounted',\n    value: function objectMounted(object) {\n      (0, _invariant2.default)(!this._objectsByUUID[object.uuid], 'There already is an object with this uuid in the react 3d instance.');\n      this._objectsByUUID[object.uuid] = object;\n      object.userData.markup._rootInstance = this;\n\n      this._addObjectWithName(object.name, object);\n\n      if (process.env.NODE_ENV !== 'production' || process.env.ENABLE_REACT_ADDON_HOOKS === 'true') {\n        object.userData.events.on('highlight', this._objectHighlighted);\n      }\n\n      object.userData.events.emit('addedIntoRoot', object);\n      var current = object;\n      var childrenMarkup = current.userData.markup.childrenMarkup;\n\n      if (object instanceof THREE.Material) {\n        this._materials.push(object);\n      }\n\n      if (object instanceof THREE.Geometry || object instanceof THREE.BufferGeometry) {\n        this._geometries.push(object);\n      }\n\n      if (object instanceof THREE.Texture) {\n        this._textures.push(object);\n      }\n\n      for (var i = 0; i < childrenMarkup.length; ++i) {\n        var childMarkup = childrenMarkup[i];\n        this.objectMounted(childMarkup.threeObject);\n      }\n    }\n  }, {\n    key: 'allMaterialsNeedUpdate',\n    value: function allMaterialsNeedUpdate(dispose) {\n      this._materials.forEach(function (material) {\n        if (dispose) {\n          material.dispose();\n        } else {\n          material.needsUpdate = true;\n        }\n      });\n    }\n  }, {\n    key: 'objectRenamed',\n    value: function objectRenamed(object, oldName, nextName) {\n      this._removeObjectWithName(oldName, object);\n\n      this._addObjectWithName(nextName, object);\n    }\n  }, {\n    key: '_addObjectWithName',\n    value: function _addObjectWithName(objectName, object) {\n      if (!this._objectsByName[objectName]) {\n        this._objectsByName[objectName] = {\n          count: 0,\n          values: {}\n        };\n      }\n\n      this._objectsByName[objectName].values[object.uuid] = object;\n      this._objectsByName[objectName].count++;\n    }\n  }, {\n    key: '_removeObjectWithName',\n    value: function _removeObjectWithName(objectName, object) {\n      (0, _invariant2.default)(this._objectsByName[objectName] && this._objectsByName[objectName].values[object.uuid] === object, 'The object\\'s name changed somehow?\\'');\n      delete this._objectsByName[objectName].values[object.uuid];\n      this._objectsByName[objectName].count--;\n\n      if (this._objectsByName[objectName].count === 0) {\n        delete this._objectsByName[objectName];\n      }\n    }\n  }, {\n    key: 'objectRemoved',\n    value: function objectRemoved(object) {\n      (0, _invariant2.default)(this._objectsByUUID[object.uuid] === object, 'The removed object does not belong here!?');\n\n      if (process.env.NODE_ENV !== 'production' || process.env.ENABLE_REACT_ADDON_HOOKS === 'true') {\n        if (this._highlightObjectId === object.uuid) {\n          this._highlightObjectId = null;\n        }\n\n        object.userData.events.removeListener('highlight', this._objectHighlighted);\n        object.userData.events.removeListener('hideHighlight', this._hideHighlight);\n      }\n\n      delete this._objectsByUUID[object.uuid];\n\n      if (object instanceof THREE.Material) {\n        this._materials.splice(this._materials.indexOf(object), 1);\n      }\n\n      if (object instanceof THREE.Geometry || object instanceof THREE.BufferGeometry) {\n        this._geometries.splice(this._geometries.indexOf(object), 1);\n      }\n\n      if (object instanceof THREE.Texture) {\n        this._textures.splice(this._textures.indexOf(object), 1);\n      }\n\n      this._removeObjectWithName(object.name, object);\n\n      delete object.userData.markup._rootInstance;\n    }\n  }, {\n    key: 'mountedIntoRoot',\n    value: function mountedIntoRoot() {\n      this._mounted = true;\n      this.objectMounted(this);\n    }\n  }]);\n\n  return React3DInstance;\n}(), _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this._callOnAnimate = function () {\n    if (_this2._onAnimate) {\n      _ReactUpdates2.default.batchedUpdates(_this2._onAnimate);\n    }\n  };\n\n  this._render = function () {\n    for (var i = 0; i < _this2._modules.length; ++i) {\n      _this2._modules[i].update();\n    }\n\n    if (_this2._forceManualRender) {\n      _this2._renderRequest = null;\n    } else {\n      _this2._renderRequest = (0, _raf2.default)(_this2._render);\n    }\n\n    _this2.userData.events.emit('animate'); // the scene can be destroyed within the 'animate' event\n\n\n    if (!_this2._scene || !_this2._mounted || !_this2._renderer) {\n      return;\n    }\n\n    var mainCamera = null;\n\n    if (_this2._mainCameraName) {\n      var objectsWithMainCameraName = _this2._objectsByName[_this2._mainCameraName];\n\n      if (objectsWithMainCameraName) {\n        if (process.env.NODE_ENV !== 'production') {\n          (0, _warning2.default)(objectsWithMainCameraName.count < 2, 'There are multiple objects with name ' + _this2._mainCameraName);\n        }\n\n        if (objectsWithMainCameraName.count > 0) {\n          var values = objectsWithMainCameraName.values;\n          mainCamera = values[Object.keys(values)[0]];\n        }\n      }\n    }\n\n    if (mainCamera) {\n      if (_this2._lastRenderMode !== 'camera') {\n        _this2._renderer.autoClear = true;\n\n        _this2._renderer.setViewport(0, 0, _this2._parameters.width, _this2._parameters.height);\n\n        _this2._lastRenderMode = 'camera';\n      }\n\n      _CameraUtils2.default.current = mainCamera;\n\n      _this2.userData.events.emit('preRender');\n\n      _this2._renderScene(mainCamera);\n\n      _CameraUtils2.default.current = null;\n    } else if (_this2._viewports.length > 0) {\n      if (_this2._lastRenderMode !== 'viewport') {\n        _this2._renderer.autoClear = false;\n        _this2._lastRenderMode = 'viewport';\n      }\n\n      _this2._renderer.clear();\n\n      _this2._viewports.forEach(function (viewport) {\n        var viewportCamera = null;\n\n        if (viewport.cameraName) {\n          var objectsWithViewportCameraName = _this2._objectsByName[viewport.cameraName];\n\n          if (objectsWithViewportCameraName) {\n            if (process.env.NODE_ENV !== 'production') {\n              (0, _warning2.default)(objectsWithViewportCameraName.count < 2, 'There are multiple objects with name ' + viewport.cameraName);\n            }\n\n            if (objectsWithViewportCameraName.count > 0) {\n              var _values = objectsWithViewportCameraName.values;\n              viewportCamera = _values[Object.keys(_values)[0]];\n            }\n          }\n        }\n\n        if (!viewportCamera) {\n          return;\n        }\n\n        if (viewport.onBeforeRender) {\n          _ReactUpdates2.default.batchedUpdates(viewport.onBeforeRender);\n        }\n\n        _this2._renderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);\n\n        _CameraUtils2.default.current = viewportCamera;\n\n        _this2.userData.events.emit('preRender');\n\n        _this2._renderScene(viewportCamera);\n\n        _CameraUtils2.default.current = null;\n      });\n    }\n  };\n}, _temp);\nmodule.exports = React3DInstance;","map":null,"metadata":{},"sourceType":"script"}