{"ast":null,"code":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _class, _temp, _class2, _temp2;\n\nvar _three = require('three');\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _ReactElement = require('react/lib/ReactElement');\n\nvar _ReactElement2 = _interopRequireDefault(_ReactElement);\n\nvar _ReactCurrentOwner = require('react/lib/ReactCurrentOwner');\n\nvar _ReactCurrentOwner2 = _interopRequireDefault(_ReactCurrentOwner);\n\nvar _ReactBaseClasses = require('react/lib/ReactBaseClasses');\n\nvar _KeyEscapeUtils = require('react/lib/KeyEscapeUtils');\n\nvar _KeyEscapeUtils2 = _interopRequireDefault(_KeyEscapeUtils);\n\nvar _emptyObject = require('fbjs/lib/emptyObject');\n\nvar _emptyObject2 = _interopRequireDefault(_emptyObject);\n\nvar _invariant = require('fbjs/lib/invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _warning = require('fbjs/lib/warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nvar _ReactInstanceMap = require('react-dom/lib/ReactInstanceMap');\n\nvar _ReactInstanceMap2 = _interopRequireDefault(_ReactInstanceMap);\n\nvar _ReactReconciler = require('react-dom/lib/ReactReconciler');\n\nvar _ReactReconciler2 = _interopRequireDefault(_ReactReconciler);\n\nvar _ReactUpdates = require('react-dom/lib/ReactUpdates');\n\nvar _ReactUpdates2 = _interopRequireDefault(_ReactUpdates);\n\nvar _ReactUpdateQueue = require('react-dom/lib/ReactUpdateQueue');\n\nvar _ReactUpdateQueue2 = _interopRequireDefault(_ReactUpdateQueue);\n\nvar _ReactInjection = require('react-dom/lib/ReactInjection');\n\nvar _ReactInjection2 = _interopRequireDefault(_ReactInjection);\n\nvar _ReactReconcileTransaction = require('react-dom/lib/ReactReconcileTransaction');\n\nvar _ReactReconcileTransaction2 = _interopRequireDefault(_ReactReconcileTransaction);\n\nvar _ReactDefaultBatchingStrategy = require('react-dom/lib/ReactDefaultBatchingStrategy');\n\nvar _ReactDefaultBatchingStrategy2 = _interopRequireDefault(_ReactDefaultBatchingStrategy);\n\nvar _traverseAllChildren = require('react-dom/lib/traverseAllChildren');\n\nvar _traverseAllChildren2 = _interopRequireDefault(_traverseAllChildren);\n\nvar _getHostComponentFromComposite = require('react-dom/lib/getHostComponentFromComposite');\n\nvar _getHostComponentFromComposite2 = _interopRequireDefault(_getHostComponentFromComposite);\n\nvar _shouldUpdateReactComponent = require('react-dom/lib/shouldUpdateReactComponent');\n\nvar _shouldUpdateReactComponent2 = _interopRequireDefault(_shouldUpdateReactComponent);\n\nvar _ReactInstrumentation = require('react-dom/lib/ReactInstrumentation');\n\nvar _ReactInstrumentation2 = _interopRequireDefault(_ReactInstrumentation);\n\nvar _React3ContainerInfo = require('./React3ContainerInfo');\n\nvar _React3ContainerInfo2 = _interopRequireDefault(_React3ContainerInfo);\n\nvar _EventDispatcher = require('./utils/EventDispatcher');\n\nvar _EventDispatcher2 = _interopRequireDefault(_EventDispatcher);\n\nvar _InternalComponent = require('./InternalComponent');\n\nvar _InternalComponent2 = _interopRequireDefault(_InternalComponent);\n\nvar _React3ComponentTree = require('./React3ComponentTree');\n\nvar _React3ComponentTree2 = _interopRequireDefault(_React3ComponentTree);\n\nvar _ElementDescriptorContainer = require('./ElementDescriptorContainer');\n\nvar _ElementDescriptorContainer2 = _interopRequireDefault(_ElementDescriptorContainer);\n\nvar _React3CompositeComponentWrapper = require('./React3CompositeComponentWrapper');\n\nvar _React3CompositeComponentWrapper2 = _interopRequireDefault(_React3CompositeComponentWrapper);\n\nvar _idPropertyName = require('./utils/idPropertyName');\n\nvar _idPropertyName2 = _interopRequireDefault(_idPropertyName);\n\nvar _removeDevTool = require('./utils/removeDevTool');\n\nvar _removeDevTool2 = _interopRequireDefault(_removeDevTool);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar getDeclarationErrorAddendum = void 0;\nvar staticDebugIdHack = void 0;\nvar ReactComponentTreeHook = void 0;\n\nif (process.env.NODE_ENV !== 'production') {\n  /* eslint-disable global-require */\n  if (!ReactComponentTreeHook) {\n    ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');\n  }\n  /* eslint-enable global-require */\n\n}\n\nif (process.env.NODE_ENV !== 'production') {\n  staticDebugIdHack = 0; // prop type helpers\n  // the warnings for propTypes will not say <anonymous>.\n  // Some performance is sacrificed for this.\n  // TODO: could have an env variable to disable this?\n\n  if (!THREE._renamed) {\n    THREE._renamed = true;\n    THREE.Vector2.displayName = 'THREE.Vector2';\n    THREE.Vector3.displayName = 'THREE.Vector3';\n    THREE.Quaternion.displayName = 'THREE.Quaternion';\n    THREE.Color.displayName = 'THREE.Color';\n    THREE.Shape.displayName = 'THREE.Shape';\n    THREE.Euler.displayName = 'THREE.Euler';\n    THREE.Fog.displayName = 'THREE.Fog';\n  }\n\n  getDeclarationErrorAddendum = function getDeclarationErrorAddendum(owner) {\n    if (owner) {\n      var name = owner.getName();\n\n      if (name) {\n        return ' Check the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  };\n}\n/**\r\n * Unmounts a component and removes it from the DOM.\r\n *\r\n * @param {ReactComponent} instance React component instance.\r\n * @param {*} container DOM element to unmount from.\r\n * @param {bool} safely\r\n * @final\r\n * @internal\r\n * @see {ReactMount.unmountComponentAtNode}\r\n */\n\n\nfunction unmountComponentFromNode(instance, container, safely) {\n  if (process.env.NODE_ENV !== 'production') {\n    _ReactInstrumentation2.default.debugTool.onBeginFlush();\n  }\n\n  _ReactReconciler2.default.unmountComponent(instance, safely);\n\n  if (process.env.NODE_ENV !== 'production') {\n    _ReactInstrumentation2.default.debugTool.onEndFlush();\n  }\n}\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\n\nvar TopLevelWrapper = (_temp = _class = function (_ReactComponent) {\n  _inherits(TopLevelWrapper, _ReactComponent);\n\n  function TopLevelWrapper() {\n    _classCallCheck(this, TopLevelWrapper);\n\n    return _possibleConstructorReturn(this, (TopLevelWrapper.__proto__ || Object.getPrototypeOf(TopLevelWrapper)).apply(this, arguments));\n  }\n\n  _createClass(TopLevelWrapper, [{\n    key: 'render',\n    value: function render() {\n      return this.props.child;\n    }\n  }]);\n\n  return TopLevelWrapper;\n}(_ReactBaseClasses.Component), _class.isReactComponent = {}, _class.isReactTopLevelWrapper = true, _temp);\n\nif (process.env.NODE_ENV !== 'production') {\n  TopLevelWrapper.displayName = 'TopLevelWrapper';\n}\n\nfunction internalGetID(markup) {\n  return markup && markup[_idPropertyName2.default] || '';\n} // see ReactMount.js:getReactRootElementInContainer\n\n/**\r\n * @param {THREE.Object3D|HTMLCanvasElement} container That may contain\r\n * a React component\r\n * @return {?*} The markup that may have the reactRoot ID, or null.\r\n */\n\n\nfunction getReactRootMarkupInContainer(container) {\n  if (!container) {\n    return null;\n  } // in ReactMount this is container.firstChild.\n\n\n  return container.userData && container.userData.markup && container.userData.markup.childrenMarkup[0] || null;\n}\n/**\r\n * Check if the type reference is a known internal type. I.e. not a user\r\n * provided composite type.\r\n *\r\n * @param {function} type\r\n * @return {boolean} Returns true if this is a valid internal type.\r\n */\n\n\nfunction isInternalComponentType(type) {\n  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';\n}\n\nvar React3Renderer = (_temp2 = _class2 = function () {\n  _createClass(React3Renderer, [{\n    key: 'updateChildren',\n\n    /**\r\n     * @see ReactChildReconciler.updateChildren\r\n     *\r\n     * Cloned because it uses\r\n     * @see React3Renderer.instantiateReactComponent\r\n     *\r\n     * Updates the rendered children and returns a new set of children.\r\n     *\r\n     * @param {?object} prevChildren Previously initialized set of children.\r\n     * @param {?object} nextChildren Flat child element maps.\r\n     * @param mountImages\r\n     * @param {?object} removedMarkups The map for removed nodes.\r\n     * @param {ReactReconcileTransaction} transaction\r\n     * @param hostParent\r\n     * @param hostContainerInfo\r\n     * @param {object} context\r\n     * @param selfDebugID\r\n     * @return {?object} A new set of child instances.\r\n     * @internal\r\n     */\n    value: function updateChildren(prevChildren, nextChildren, mountImages, removedMarkups, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots\n    ) {\n      // We currently don't have a way to track moves here but if we use iterators\n      // instead of for..in we can zip the iterators and check if an item has\n      // moved.\n      // TODO: If nothing has changed, return the prevChildren object so that we\n      // can quickly bailout.\n      if (!nextChildren && !prevChildren) {\n        return null;\n      }\n\n      if (nextChildren) {\n        var nextChildrenKeys = Object.keys(nextChildren);\n\n        for (var i = 0; i < nextChildrenKeys.length; ++i) {\n          var childName = nextChildrenKeys[i];\n          var prevChild = prevChildren && prevChildren[childName];\n          var prevElement = prevChild && prevChild._currentElement;\n          var nextElement = nextChildren[childName];\n\n          if (prevChild !== null && prevChild !== undefined && (0, _shouldUpdateReactComponent2.default)(prevElement, nextElement)) {\n            _ReactReconciler2.default.receiveComponent(prevChild, nextElement, transaction, context);\n\n            if (prevChild._forceRemountOfComponent) {\n              removedMarkups[childName] = prevChild.getHostMarkup();\n\n              _ReactReconciler2.default.unmountComponent(prevChild, false);\n\n              var nextChildInstance = this.instantiateReactComponent(nextElement, true);\n              nextChildren[childName] = nextChildInstance; // Creating mount image now ensures refs are resolved in right order\n              // (see https://github.com/facebook/react/pull/7101 for explanation).\n\n              var nextChildMountImage = _ReactReconciler2.default.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);\n\n              mountImages.push(nextChildMountImage);\n            } else {\n              nextChildren[childName] = prevChild;\n            }\n          } else {\n            if (prevChild) {\n              removedMarkups[childName] = prevChild.getHostMarkup();\n\n              _ReactReconciler2.default.unmountComponent(prevChild, false);\n            } // The child must be instantiated before it's mounted.\n\n\n            var _nextChildInstance = this.instantiateReactComponent(nextElement, true);\n\n            nextChildren[childName] = _nextChildInstance; // Creating mount image now ensures refs are resolved in right order\n            // (see https://github.com/facebook/react/pull/7101 for explanation).\n\n            var _nextChildMountImage = _ReactReconciler2.default.mountComponent(_nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID\n            /* parentDebugID */\n            );\n\n            mountImages.push(_nextChildMountImage);\n          }\n        }\n      }\n\n      if (prevChildren) {\n        // Unmount children that are no longer present.\n        var prevChildrenKeys = Object.keys(prevChildren);\n\n        for (var _i = 0; _i < prevChildrenKeys.length; ++_i) {\n          var _childName = prevChildrenKeys[_i];\n\n          if (!(nextChildren && nextChildren.hasOwnProperty(_childName))) {\n            var _prevChild = prevChildren[_childName];\n            removedMarkups[_childName] = _prevChild.getHostMarkup();\n\n            _ReactReconciler2.default.unmountComponent(_prevChild, false);\n          }\n        }\n      }\n\n      return nextChildren;\n    }\n  }, {\n    key: 'getElementDescriptor',\n    value: function getElementDescriptor(name) {\n      return this.threeElementDescriptors[name];\n    }\n  }], [{\n    key: 'findTHREEObject',\n\n    /**\r\n     * Returns the THREE.js object rendered by this element.\r\n     *\r\n     * @param {React.Component|THREE.Object3D|HTMLCanvasElement} componentOrElement\r\n     * @return {?THREE.Object3D} The root node of this element.\r\n     */\n    value: function findTHREEObject(componentOrElement) {\n      if (process.env.NODE_ENV !== 'production') {\n        var owner = _ReactCurrentOwner2.default.current;\n\n        if (owner !== null) {\n          if (process.env.NODE_ENV !== 'production') {\n            (0, _warning2.default)(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component');\n          }\n\n          owner._warnedAboutRefsInRender = true;\n        }\n      }\n\n      if (componentOrElement === null) {\n        return null;\n      }\n\n      if (componentOrElement instanceof THREE.Object3D || componentOrElement instanceof HTMLCanvasElement) {\n        return componentOrElement;\n      }\n\n      if (_ReactInstanceMap2.default.has(componentOrElement)) {\n        var instance = _ReactInstanceMap2.default.get(componentOrElement);\n\n        instance = (0, _getHostComponentFromComposite2.default)(instance);\n        return instance ? _React3ComponentTree2.default.getMarkupFromInstance(instance).threeObject : null;\n      }\n\n      if (!(componentOrElement.render === null || typeof componentOrElement.render !== 'function')) {\n        if (process.env.NODE_ENV !== 'production') {\n          (0, _invariant2.default)(false, 'Component (with keys: %s) contains `render` method ' + 'but is not mounted', Object.keys(componentOrElement));\n        } else {\n          (0, _invariant2.default)(false);\n        }\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        (0, _invariant2.default)(false, 'Element appears to be neither ReactComponent, ' + 'a THREE.js object, nor a HTMLCanvasElement (keys: %s)', Object.keys(componentOrElement));\n      } else {\n        (0, _invariant2.default)(false);\n      }\n\n      return null;\n    } // to be used by modules e.g. mouse input ( see examples )\n\n  }]);\n\n  function React3Renderer() {\n    var _this2 = this;\n\n    _classCallCheck(this, React3Renderer);\n\n    this.instantiateChild = function (childInstances, child, name, selfDebugID) {\n      // We found a component instance.\n      var keyUnique = childInstances[name] === undefined;\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (!keyUnique) {\n          (0, _warning2.default)(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', _KeyEscapeUtils2.default.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID));\n        }\n      }\n\n      if (child !== null && keyUnique) {\n        childInstances[name] = _this2.instantiateReactComponent(child, true);\n      }\n    };\n\n    this.findNodeHandle = function (instance) {\n      var inst = _React3ComponentTree2.default.getRenderedHostOrTextFromComponent(instance);\n\n      if (!inst || !inst._threeObject) {\n        return null;\n      }\n\n      var markup = _React3ComponentTree2.default.getMarkupFromInstance(inst);\n\n      _this2._highlightCache = markup;\n      return _this2._highlightElement;\n    };\n\n    this.nativeTagToRootNodeID = function () {\n      return 0;\n    };\n\n    this.hostTagToRootNodeID = function () {\n      return 0;\n    };\n\n    this.batchedMountComponentIntoNode = function (componentInstance, container, shouldReuseMarkup, context) {\n      var transaction = _ReactUpdates2.default.ReactReconcileTransaction.getPooled(!shouldReuseMarkup);\n\n      transaction.perform(_this2.mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);\n\n      _ReactUpdates2.default.ReactReconcileTransaction.release(transaction);\n    };\n\n    this.mountComponentIntoNode = function (wrapperInstance, container, transaction, shouldReuseMarkup, context) {\n      var markup = _ReactReconciler2.default.mountComponent(wrapperInstance, transaction, null, (0, _React3ContainerInfo2.default)(wrapperInstance, container), context, 0\n      /* parentDebugID */\n      );\n\n      wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;\n\n      _this2._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);\n    };\n\n    this._instancesByReactRootID = {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      this.rootMarkupsByReactRootID = {};\n    }\n\n    this.nextMountID = 1;\n    this.globalIdCounter = 1;\n    this.nextReactRootIndex = 0;\n    this.threeElementDescriptors = new _ElementDescriptorContainer2.default(this).descriptors;\n    this._highlightElement = document.createElement('div');\n    this._highlightCache = null;\n\n    if (process.env.NODE_ENV !== 'production') {\n      this._nextDebugID = 1;\n      this._debugIdPrefix = staticDebugIdHack++;\n    }\n\n    if (process.env.NODE_ENV !== 'production' || process.env.ENABLE_REACT_ADDON_HOOKS === 'true') {\n      this._agent = null;\n\n      this._onHideHighlightFromInspector = function () {\n        if (_this2._highlightCache && _this2._highlightCache.threeObject.userData.react3internalComponent) {\n          var internalComponent = _this2._highlightCache.threeObject.userData.react3internalComponent;\n          internalComponent.hideHighlight();\n          _this2._highlightCache = null;\n        }\n      };\n\n      this._onHighlightFromInspector = function (highlightInfo) {\n        if (highlightInfo.node === _this2._highlightElement) {\n          if (_this2._highlightCache && _this2._highlightCache.threeObject.userData.react3internalComponent) {\n            var internalComponent = _this2._highlightCache.threeObject.userData.react3internalComponent;\n            internalComponent.highlightComponent();\n          }\n        }\n      };\n\n      this._hookAgent = function (agent) {\n        _this2._agent = agent; // agent.on('startInspecting', (...args) => {\n        //   console.log('start inspecting?', args);\n        // });\n        // agent.on('setSelection', (...args) => {\n        //   console.log('set selection?', args);\n        // });\n        // agent.on('selected', (...args) => {\n        //   console.log('selected?', args);\n        // });\n\n        agent.on('highlight', _this2._onHighlightFromInspector);\n        agent.on('hideHighlight', _this2._onHideHighlightFromInspector); // agent.on('highlightMany', (...args) => {\n        //   console.log('highlightMany?', args);\n        // });\n      }; // Inject the runtime into a devtools global hook regardless of browser.\n      // Allows for debugging when the hook is injected on the page.\n\n\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {\n        this._devToolsRendererDefinition = {\n          ComponentTree: {\n            getClosestInstanceFromNode: function getClosestInstanceFromNode(node) {\n              return _React3ComponentTree2.default.getClosestInstanceFromMarkup(node);\n            },\n            getNodeFromInstance: function getNodeFromInstance(instInput) {\n              var inst = instInput; // inst is an internal instance (but could be a composite)\n\n              while (inst._renderedComponent) {\n                inst = inst._renderedComponent;\n              }\n\n              if (inst) {\n                return _React3ComponentTree2.default.getMarkupFromInstance(inst);\n              }\n\n              return null;\n            }\n          },\n          Mount: this,\n          Reconciler: _ReactReconciler2.default,\n          TextComponent: _InternalComponent2.default\n        };\n\n        var rendererListener = function rendererListener(info) {\n          _this2._reactDevtoolsRendererId = info.id;\n\n          _this2._rendererListenerCleanup();\n\n          delete _this2._rendererListenerCleanup;\n        };\n\n        this._rendererListenerCleanup = __REACT_DEVTOOLS_GLOBAL_HOOK__.sub('renderer', rendererListener);\n\n        __REACT_DEVTOOLS_GLOBAL_HOOK__.inject(this._devToolsRendererDefinition);\n\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.reactDevtoolsAgent !== 'undefined' && __REACT_DEVTOOLS_GLOBAL_HOOK__.reactDevtoolsAgent) {\n          var agent = __REACT_DEVTOOLS_GLOBAL_HOOK__.reactDevtoolsAgent;\n\n          this._hookAgent(agent);\n        } else {\n          this._devtoolsCallbackCleanup = __REACT_DEVTOOLS_GLOBAL_HOOK__.sub('react-devtools', function (agent) {\n            _this2._devtoolsCallbackCleanup();\n\n            _this2._hookAgent(agent);\n          });\n        }\n      }\n    }\n  }\n  /**\r\n   * @see ReactChildReconciler.instantiateChild\r\n   * Cloned because it uses\r\n   * @see React3Renderer.instantiateReactComponent\r\n   *\r\n   * @param childInstances\r\n   * @param child\r\n   * @param name\r\n   * @param selfDebugID\r\n   */\n\n\n  _createClass(React3Renderer, [{\n    key: 'instantiateChildren',\n\n    /**\r\n     * @see ReactChildReconciler.instantiateChildren\r\n     * Cloned because it uses\r\n     * @see React3Renderer.instantiateChild\r\n     *\r\n     * Generates a \"mount image\" for each of the supplied children. In the case\r\n     * of `ReactDOMComponent`, a mount image is a string of markup.\r\n     *\r\n     * @param {?object} nestedChildNodes Nested child maps.\r\n     * @param transaction\r\n     * @param context\r\n     * @param selfDebugID\r\n     * @return {?object} A set of child instances.\r\n     * @internal\r\n     */\n    value: function instantiateChildren(nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots\n    ) {\n      var _this3 = this;\n\n      if (nestedChildNodes === null) {\n        return null;\n      }\n\n      var childInstances = {};\n\n      if (process.env.NODE_ENV !== 'production') {\n        (0, _traverseAllChildren2.default)(nestedChildNodes, function (childInsts, child, name) {\n          return _this3.instantiateChild(childInsts, child, name, selfDebugID);\n        }, childInstances);\n      } else {\n        (0, _traverseAllChildren2.default)(nestedChildNodes, this.instantiateChild, childInstances);\n      }\n\n      return childInstances;\n    }\n  }, {\n    key: 'containsChild',\n    value: function containsChild(container, markup) {\n      var childrenMarkup = container.userData.markup.childrenMarkup;\n\n      for (var i = 0; i < childrenMarkup.length; i++) {\n        if (childrenMarkup[i] === markup) {\n          return true;\n        }\n      }\n\n      return false;\n    } // DO NOT RENAME\n    // used by react devtools!\n    // used by react devtools\n\n  }, {\n    key: '_mountImageIntoNode',\n    value: function _mountImageIntoNode(markup, container, instance, shouldReuseMarkup, transaction) {\n      // eslint-disable-line no-unused-vars\n      // TODO try to do server-side rendering for THREE\n      if (!container.userData) {\n        // it has to be a HTMLCanvasElement I guess?\n        (0, _invariant2.default)(container instanceof HTMLCanvasElement, 'The root container can only be a THREE.js object ' + '(with an userData property) or HTMLCanvasElement.');\n        container.userData = {\n          _createdByReact3: true\n        };\n      }\n\n      var rootImage = markup;\n      var rootMarkup = {\n        threeObject: container,\n        parentMarkup: null,\n        childrenMarkup: [rootImage],\n        toJSON: function toJSON() {\n          return '---MARKUP---';\n        }\n      };\n      Object.assign(container.userData, {\n        object3D: container,\n        toJSON: function toJSON() {\n          return '---USERDATA---';\n        },\n        markup: rootMarkup\n      });\n      rootImage.parentMarkup = rootMarkup;\n      var descriptorForChild = this.threeElementDescriptors[rootImage.elementType];\n      descriptorForChild.setParent(rootImage.threeObject, rootMarkup.threeObject); // all objects now added can be marked as added to scene now!\n\n      rootImage.threeObject.mountedIntoRoot();\n      var firstChild = container.userData.markup.childrenMarkup[0];\n\n      _React3ComponentTree2.default.precacheMarkup(instance, firstChild);\n\n      if (process.env.NODE_ENV !== 'production') {\n        var hostInstance = _React3ComponentTree2.default.getInstanceFromMarkup(firstChild);\n\n        if (hostInstance._debugID !== 0) {\n          _ReactInstrumentation2.default.debugTool.onHostOperation({\n            instanceID: hostInstance._debugID,\n            type: 'mount',\n            payload: markup.toString()\n          });\n        }\n      }\n    }\n    /**\r\n     *\r\n     * @param nextElement A react element\r\n     * @param container A canvas or a THREE.js object\r\n     * @param callback The callback function\r\n     * @returns {*}\r\n     */\n\n  }, {\n    key: 'render',\n    value: function render(nextElement, container, callback) {\n      return this._renderSubtreeIntoContainer(null, nextElement, container, callback);\n    }\n  }, {\n    key: 'getHostRootInstanceInContainer',\n    value: function getHostRootInstanceInContainer(container) {\n      var rootMarkup = getReactRootMarkupInContainer(container);\n\n      var prevHostInstance = rootMarkup && _React3ComponentTree2.default.getInstanceFromMarkup(rootMarkup);\n\n      return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;\n    }\n  }, {\n    key: 'getTopLevelWrapperInContainer',\n    value: function getTopLevelWrapperInContainer(container) {\n      var root = this.getHostRootInstanceInContainer(container);\n\n      if (root) {\n        (0, _invariant2.default)(!!root._hostContainerInfo, 'Root should have native container info %s', ' but it does not');\n      }\n\n      return root ? root._hostContainerInfo._topLevelWrapper : null;\n    }\n  }, {\n    key: '_renderSubtreeIntoContainer',\n    value: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {\n      if (!_ReactElement2.default.isValidElement(nextElement)) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (typeof nextElement === 'string') {\n            (0, _invariant2.default)(false, 'React3Renderer.render(): Invalid component element.%s', ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.');\n          } else if (typeof nextElement === 'function') {\n            (0, _invariant2.default)(false, 'React3Renderer.render(): Invalid component element.%s', ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.');\n          } else if (nextElement !== null && nextElement.props !== undefined) {\n            (0, _invariant2.default)(false, 'React3Renderer.render(): Invalid component element.%s', ' This may be caused by unintentionally loading two independent ' + 'copies of React.');\n          } else {\n            (0, _invariant2.default)(false, 'React3Renderer.render(): Invalid component element.');\n          }\n        } else {\n          (0, _invariant2.default)(false);\n        }\n      }\n\n      var nextWrappedElement = _ReactElement2.default.createElement(TopLevelWrapper, {\n        child: nextElement\n      });\n\n      var nextContext = void 0;\n\n      if (parentComponent) {\n        var parentInst = _ReactInstanceMap2.default.get(parentComponent);\n\n        nextContext = parentInst._processChildContext(parentInst._context);\n      } else {\n        nextContext = _emptyObject2.default;\n      }\n\n      var prevComponent = this.getTopLevelWrapperInContainer(container);\n\n      if (prevComponent) {\n        var prevWrappedElement = prevComponent._currentElement;\n        var prevElement = prevWrappedElement.props.child;\n\n        if ((0, _shouldUpdateReactComponent2.default)(prevElement, nextElement)) {\n          var publicInst = prevComponent._renderedComponent.getPublicInstance();\n\n          var updatedCallback = callback && function () {\n            callback.call(publicInst);\n          };\n\n          this._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);\n\n          return publicInst;\n        }\n\n        this.unmountComponentAtNode(container);\n      } // aka first child\n\n\n      var reactRootMarkup = getReactRootMarkupInContainer(container);\n      var containerHasReactMarkup = reactRootMarkup && !!internalGetID(reactRootMarkup); // containerHasNonRootReactChild not implemented\n\n      var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;\n\n      var component = this._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();\n\n      if (callback) {\n        callback.call(component);\n      }\n\n      return component;\n    }\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      var rootIds = Object.keys(this._instancesByReactRootID);\n\n      for (var i = 0; i < rootIds.length; ++i) {\n        this.unmountComponentAtNode(this._instancesByReactRootID[rootIds[i]].getHostMarkup().parentMarkup.threeObject);\n      }\n\n      delete this._instancesByReactRootID;\n\n      if (process.env.NODE_ENV !== 'production') {\n        delete this.rootMarkupsByReactRootID;\n      }\n\n      delete this._highlightElement;\n      this.nextMountID = 1;\n      this.nextReactRootIndex = 0;\n\n      if (process.env.NODE_ENV !== 'production' || process.env.ENABLE_REACT_ADDON_HOOKS === 'true') {\n        if (this._devtoolsCallbackCleanup) {\n          this._devtoolsCallbackCleanup();\n\n          delete this._devtoolsCallbackCleanup;\n        }\n\n        if (this._rendererListenerCleanup) {\n          this._rendererListenerCleanup();\n\n          delete this._rendererListenerCleanup;\n        }\n\n        if (this._devToolsRendererDefinition) {\n          if (this._agent) {\n            this._agent.onUnmounted(this._devToolsRendererDefinition);\n\n            this._agent.removeListener('highlight', this._onHighlightFromInspector);\n\n            this._agent.removeListener('hideHighlight', this._onHideHighlightFromInspector);\n          }\n\n          if (this._reactDevtoolsRendererId) {\n            delete __REACT_DEVTOOLS_GLOBAL_HOOK__._renderers[this._reactDevtoolsRendererId];\n            delete this._reactDevtoolsRendererId;\n          }\n\n          delete this._devToolsRendererDefinition;\n          delete this._agent;\n        }\n\n        delete this._onHighlightFromInspector;\n        delete this._onHideHighlightFromInspector;\n        delete this._hookAgent;\n      }\n    }\n  }, {\n    key: '_updateRootComponent',\n    value: function _updateRootComponent(prevComponent, nextElement, nextContext, container, callback) {\n      _ReactUpdateQueue2.default.enqueueElementInternal(prevComponent, nextElement, nextContext);\n\n      if (callback) {\n        _ReactUpdateQueue2.default.enqueueCallbackInternal(prevComponent, callback);\n      }\n\n      return prevComponent;\n    }\n    /**\r\n     * True if the supplied DOM node has a direct React-rendered child that is\r\n     * not a React root element. Useful for warning in `render`,\r\n     * `unmountComponentAtNode`, etc.\r\n     *\r\n     * @param {?*} container The container.\r\n     * @return {boolean} True if the DOM element contains a direct child that was\r\n     * rendered by React but is not a root element.\r\n     * @internal\r\n     */\n\n  }, {\n    key: 'hasNonRootReactChild',\n    value: function hasNonRootReactChild(container) {\n      var rootMarkup = getReactRootMarkupInContainer(container);\n\n      if (rootMarkup) {\n        var inst = _React3ComponentTree2.default.getInstanceFromMarkup(rootMarkup);\n\n        return !!(inst && inst._hostParent);\n      }\n\n      return false;\n    }\n  }, {\n    key: 'unmountComponentAtNode',\n    value: function unmountComponentAtNode(container) {\n      // Various parts of our code (such as ReactCompositeComponent's\n      // _renderValidatedComponent) assume that calls to render aren't nested;\n      // verify that that's the case. (Strictly speaking, unmounting won't cause a\n      // render but we still don't expect to be in a render call here.)\n      if (process.env.NODE_ENV !== 'production') {\n        (0, _warning2.default)(_ReactCurrentOwner2.default.current === null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', _ReactCurrentOwner2.default.current && _ReactCurrentOwner2.default.current.getName() || 'ReactCompositeComponent');\n      }\n\n      var prevComponent = this.getTopLevelWrapperInContainer(container);\n\n      if (!prevComponent) {\n        // Check if the node being unmounted was rendered by React, but isn't a\n        // root node.\n        var containerHasNonRootReactChild = this.hasNonRootReactChild(container); // Check if the container itself is a React root node.\n\n        var isContainerReactRoot = !!(container && container.userData && container.userData.markup && container.userData.markup[_idPropertyName2.default]);\n\n        if (process.env.NODE_ENV !== 'production') {\n          (0, _warning2.default)(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');\n        }\n\n        return false;\n      }\n\n      delete this._instancesByReactRootID[prevComponent._instance.rootID];\n\n      _ReactUpdates2.default.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);\n\n      if (container && container.userData && container.userData._createdByReact3) {\n        delete container.userData;\n      }\n\n      return true;\n    }\n    /**\r\n     * @param {THREE.Object3D|HTMLCanvasElement} container THREE Object\r\n     *   or HTML Canvas Element that may contain a React component.\r\n     * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\r\n     */\n\n  }, {\n    key: 'getReactRootID',\n    value: function getReactRootID(container) {\n      var rootMarkup = getReactRootMarkupInContainer(container);\n      return rootMarkup && this.getID(rootMarkup);\n    } // see instantiateReactComponent.js\n\n    /**\r\n     * @see #instantiateReactComponent\r\n     *\r\n     * Cloned because it uses\r\n     * @see InternalComponent\r\n     *\r\n     * @param _node ( from createElement )\r\n     * @param {boolean} shouldHaveDebugID\r\n     * @return {object} A new instance of the element's constructor.\r\n     */\n\n  }, {\n    key: 'instantiateReactComponent',\n    value: function instantiateReactComponent(_node, shouldHaveDebugID) {\n      var instance = void 0;\n      var node = _node;\n      var isEmptyNode = node === null || node === false;\n\n      if (isEmptyNode) {\n        // Create an object3D node so that empty components can be added anywhere\n        instance = new _InternalComponent2.default(_ReactElement2.default.createElement('object3D', {\n          visible: false\n        }), this); // original: instance = new ReactDOMEmptyComponent(this.instantiateReactComponent);\n      } else if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {\n        var _element = node;\n        var type = _element.type;\n\n        if (typeof type !== 'function' && typeof type !== 'string') {\n          var info = '';\n\n          if (process.env.NODE_ENV !== 'production') {\n            if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {\n              info += ' You likely forgot to export your component from the file ' + 'it\\'s defined in.';\n            }\n          }\n\n          info += getDeclarationErrorAddendum(_element._owner);\n          (0, _invariant2.default)(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', type === null || type === undefined ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info);\n        } // Special case string values\n\n\n        if (typeof _element.type === 'string') {\n          // original: instance = ReactHostComponent.createInternalComponent(element);\n          instance = new _InternalComponent2.default(_element, this);\n        } else if (isInternalComponentType(_element.type)) {\n          // This is temporarily available for custom components that are not string\n          // representations. I.e. ART. Once those are updated to use the string\n          // representation, we can drop this code path.\n          var Constructor = _element.type;\n          instance = new Constructor(_element); // We renamed this. Allow the old name for compat. :(\n\n          if (!instance.getHostNode) {\n            instance.getHostNode = instance.getNativeNode;\n          }\n        } else {\n          instance = new _React3CompositeComponentWrapper2.default(_element, this);\n        }\n      } else if (typeof node === 'string' || typeof node === 'number') {\n        // TODO create instance for text\n        if (process.env.NODE_ENV !== 'production') {\n          (0, _invariant2.default)(false, 'Encountered invalid React node of type %s : %s', typeof node === 'undefined' ? 'undefined' : _typeof(node), node);\n        } else {\n          (0, _invariant2.default)(false);\n        }\n      } else if (process.env.NODE_ENV !== 'production') {\n        (0, _invariant2.default)(false, 'Encountered invalid React node of type %s', typeof element === 'undefined' ? 'undefined' : _typeof(element));\n      } else {\n        (0, _invariant2.default)(false);\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        (0, _warning2.default)(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostMarkup === 'function' && typeof instance.unmountComponent === 'function', 'Only React 3 Components can be mounted.');\n      } // These two fields are used by the DOM and ART diffing algorithms\n      // respectively. Instead of using expandos on components, we should be\n      // storing the state needed by the diffing algorithms elsewhere.\n\n\n      instance._mountIndex = 0;\n      instance._mountImage = null;\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (shouldHaveDebugID) {\n          instance._debugID = 'r3r' + this._debugIdPrefix + '-' + this._nextDebugID++;\n        } else {\n          instance._debugID = 0;\n        }\n      } // Internal instances should fully constructed at this point, so they should\n      // not get any new fields added to them at this point.\n\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (Object.preventExtensions) {\n          Object.preventExtensions(instance);\n        }\n      }\n\n      return instance;\n    }\n    /**\r\n     * @see ReactMount._renderNewRootComponent\r\n     *\r\n     * Cloned because it uses\r\n     * @see React3Renderer.instantiateReactComponent\r\n     *\r\n     * @param nextElement\r\n     * @param {THREE.Object3D | HTMLCanvasElement} container\r\n     * @param shouldReuseMarkup\r\n     * @param context\r\n     * @returns {*}\r\n     * @private\r\n     */\n\n  }, {\n    key: '_renderNewRootComponent',\n    value: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {\n      // Various parts of our code (such as ReactCompositeComponent's\n      // _renderValidatedComponent) assume that calls to render aren't nested;\n      // verify that that's the case.\n      if (process.env.NODE_ENV !== 'production') {\n        (0, _warning2.default)(_ReactCurrentOwner2.default.current === null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', _ReactCurrentOwner2.default.current && _ReactCurrentOwner2.default.current.getName() || 'ReactCompositeComponent');\n      }\n\n      var componentInstance = this.instantiateReactComponent(nextElement, false);\n\n      if (!_ReactUpdates2.default.ReactReconcileTransaction) {\n        // If the ReactReconcileTransaction has not been injected\n        // let's just use the defaults from ReactMount.\n        _ReactInjection2.default.Updates.injectReconcileTransaction(_ReactReconcileTransaction2.default);\n\n        _ReactInjection2.default.Updates.injectBatchingStrategy(_ReactDefaultBatchingStrategy2.default);\n      }\n\n      var devToolRemoved = void 0;\n\n      if (process.env.NODE_ENV !== 'production') {\n        devToolRemoved = (0, _removeDevTool2.default)();\n      } // The initial render is synchronous but any updates that happen during\n      // rendering, in componentWillMount or componentDidMount, will be batched\n      // according to the current batching strategy.\n\n\n      _ReactUpdates2.default.batchedUpdates(this.batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (devToolRemoved) {\n          _removeDevTool2.default.restore();\n        }\n      }\n\n      var wrapperID = componentInstance._instance.rootID;\n      this._instancesByReactRootID[wrapperID] = componentInstance;\n      return componentInstance;\n    }\n    /**\r\n     * Batched mount.\r\n     *\r\n     * @param {ReactComponent} componentInstance The instance to mount.\r\n     * @param {*} container Container.\r\n     * @param {boolean} shouldReuseMarkup If true, do not insert markup\r\n     * @param {*} context que?\r\n     */\n\n    /**\r\n     * @see #mountComponentIntoNode\r\n     *\r\n     * Mounts this component and inserts it into the DOM.\r\n     *\r\n     * @param {ReactComponent} wrapperInstance The instance to mount.\r\n     * @param {*} container container to mount into.\r\n     * @param {ReactReconcileTransaction} transaction\r\n     * @param {boolean} shouldReuseMarkup If true, do not insert markup\r\n     * @param {*} context\r\n     */\n\n  }, {\n    key: 'createReactRootID',\n    value: function createReactRootID() {\n      return this.nextReactRootIndex++;\n    }\n  }, {\n    key: 'getID',\n    value: function getID(markup) {\n      return internalGetID(markup);\n    }\n  }]);\n\n  return React3Renderer;\n}(), _class2.eventDispatcher = new _EventDispatcher2.default(), _temp2);\nmodule.exports = React3Renderer;","map":null,"metadata":{},"sourceType":"script"}